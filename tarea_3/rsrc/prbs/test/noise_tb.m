function noise_tb
% -----------------------------------------------------------------
% noise_tb.m
%
% 5/12/2011 D. W. Hawkins (dwh@ovro.caltech.edu)
%
% Generate histograms and power-spectra from the output file
% generated by the digital noise source testbench noise_tb.vhd.
%
% -----------------------------------------------------------------

% -----------------------------------------------------------------
% Testbench generics
% -----------------------------------------------------------------
%
% The LFSR parameters are not needed by this script, but
% the noise sample width and number of samples used to obtain
% the sum are, since they define the noise source variance.
%
% The number of samples in the noise_tb.txt file should be 
% sufficient to generate power-spectra with normal (Gaussian)
% distribution statistics, 100 x 1024 samples is typical.
%
%NOISE_TYPE       = 'UNIFORM';
NOISE_TYPE       = 'GAUSSIAN';
NOISE_SUM        = 4;
NOISE_WIDTH      = 16;
OUTPUT_FILE_NAME = 'noise_tb.txt';
NSAMPLES         = 100*1024;

% -----------------------------------------------------------------
% Parameters
% -----------------------------------------------------------------
%

% Power spectrum calculation:
%
% Number of samples per transform
Nt = 1024;

% Number of estimates to average
Na = 100;

% Number of bits per sample
B = NOISE_WIDTH;

% Input noise power level (loading factor)
if (strcmp(NOISE_TYPE,'UNIFORM') == 1) 
	% Uniform noise
	LF_dB = 10*log10(1/3);
else
	% Gaussian noise
	LF_dB = 10*log10(1/(3*NOISE_SUM));
end

% Increase the font-size
doc_figs = 1;
if (doc_figs == 1)
	set(0, 'DefaultTextFontSize', 16);
	set(0, 'DefaultAxesFontSize', 16);
end

% Check the number of samples
if (Nt*Na ~= NSAMPLES)
	error(['Error: the number of samples in the data file ' ...
	'does not match the number expected by the m-file. ' ...
	'Please re-run the testbench or edit the m-file.']);
end

% -----------------------------------------------------------------
% Load the input file
% -----------------------------------------------------------------

x = load(OUTPUT_FILE_NAME);

% Check the number of samples
if (length(x) ~= Na*Nt)
	error('Error: the testbench data file length is incorrect.')
end

% Scale the inputs back to fractional integer (float) values
xf = x/2^(B-1);

figure(1)
hist(xf,50)
if (doc_figs == 0) 
	title('Noise histogram')
end
xlabel('Fractional integer value')
ylabel('Occurrence')

% -----------------------------------------------------------------
% Power spectra
% -----------------------------------------------------------------
%
%
% Window (applied to the Nt-sample lag response)
%w = ones(1,Nt);
%w = window(@hanning,Nt)';
w = window(@blackman,Nt)';
%w = kaiser(Nt,4*pi)';
wcg = mean(w);    % coherent gain
wig = mean(w.^2); % incoherent gain

% Zero padded final response (Nt-lags padded to Np)
Np = 4*Nt;

Rxx = calc_psd(xf', Na, Nt, Np, w);

% Calculated RMS
Rms_noise_dB    = 10*log10(var(xf));
fprintf('Signal RMS (loading factor);\n')
fprintf(' * measured %.2fdB\n', Rms_noise_dB)
fprintf(' * expected %.2fdB\n', LF_dB)

% Data frequency axis
f = [0:Np/2]/Np;

figure(2)
hold off
plot(f,10*log10(Rxx+1e-20), 'LineWidth', 1.0);
hold on
plot([f(1) f(end)],[0 0],'k:', 'LineWidth', 1.0)
%plot([f(1) f(end)],[1 1]*(LF_dB),'r:')
axis([f(1) f(end) -30 10])
xlabel('Normalized frequency')
ylabel('Magnitude (dB)')
if (doc_figs == 0) 
	title('Noise power spectrum')
end

% -----------------------------------------------------------------
% Functions
% -----------------------------------------------------------------
%
% Calculate the PSD
% * the following calculates an Na averaged PSD of Nt samples
%   using a single FFT to calculate the PSD, and then FFTs
%   to preserve the lag response of the first Nt samples.
% * the lag response is then windowed to create the PSD
%   estimate. The PSD is not normalized by the window coherent
%   or incoherent gain, since the window gain at the zeroth
%   lag of the autocorrelation is 1, i.e., the windowing
%   reduces the sidelobes and noise.
%
function y = calc_psd(x, Na, Nt, Np, w)

	% FFT length for the data frequency responses
	Nf = 2^ceil(log2(2*Na*Nt-1));

	% PSD for all samples
	X = fft([x zeros(1,Nf-(Na*Nt))]);
	Rxx = abs(X).^2;
	rxx = ifft(Rxx);

	% Re-transform and window the Nt-lag autocorrelation
	Rxx = fft([ [rxx(Nt/2:-1:2) rxx(1:Nt/2+1)].*w zeros(1,Np-Nt) ]);

	% FFT-shift and normalize
%	y = abs(fftshift(Rxx))/(Na*Nt);

	% Just return the positive frequencies
	y = abs(Rxx(1:Np/2+1))/(Na*Nt);

